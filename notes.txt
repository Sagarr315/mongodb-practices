1. What is MongoDB?
MongoDB is a NoSQL database â€” unlike traditional databases (like MySQL or SQL Server) that use tables,
MongoDB stores data in a flexible, JSON-like format called documents.
Itâ€™s perfect for applications where data structure can change often (like modern web apps).


âœ¨ Main Features (Short & Sweet):
1.Document-Oriented: Data is stored in documents (like JSON objects).
2.Schema-less: You donâ€™t need to define the structure of data (no fixed columns).
3.High Performance: Super fast for read/write operations.
4.Scalable: Handles big data easily with horizontal scaling (adding more machines).
5.Flexible: You can store arrays, nested objects, etc.



ğŸ“„ Core Concepts
1. Database
Like a folder. Contains collections.

2. Collection
Like a table in SQL, but without fixed schema. Contains documents.

Example:
users collection, products collection

3. Document
Like a row in SQL, but in JSON format.

Example:{
  "name": "John",
  "age": 25,
  "email": "john@example.com"
}

Each document can have different fields. One document can have "age", another might not.



4. _id
Every document automatically gets a unique _id field (like a primary key).

Differences Between SQL VS MongoDB Terminology:

SQL	          MongoDB

Table	         Collection
Row	         Document
Column	         Field
Primary Key	 _id
JOIN	         Embedding/Nesting (or $lookup for joins)



CRUD Operations

           READ USING:  1.find()  and  findOne()

ğŸ” find() vs findOne()

       Command                              Description
	
	find()	        Returns all matching documents as a cursor (like a pointer).
	findOne()	Returns only the first matching document (just one object).

*Cursor (from find())

	1.Acts like a pointer to the result set.
	2.You can loop through it or use .toArray() or .pretty() to display data.



*What is a Cursor in MongoDB?

	A cursor is like a pointer or iterator that MongoDB returns when you run find().

	It doesn't give you all the data at once â€” instead, it gives you a stream of documents, so you can:
	Scroll through large results efficiently
	Use .forEach(), .toArray(), or .pretty() to handle the data

*Think of it like:
        A remote control that points to your data â€” you press "next" to fetch more as needed!                

*CREATE OPERATIONS with insert 
ğŸ“¥ insertOne()
Inserts a single document into a collection.

ğŸ“¥ insertMany()
Inserts multiple documents at once (array of documents).


***UPDATE OPERATIONS

âœï¸ updateOne()
Updates only the first matching document.

âœï¸ updateMany()
Updates all matching documents.


***DElETE OPERATIONS
âŒ deleteOne()
Deletes only the first matching document.

âŒ deleteMany()
Deletes all matching documents





1ï¸âƒ£Select one field (column) from documents
ğŸ”¹ With condition:

db.collection.find({ age: 25 }, { name: 1, _id: 0 })    IT WILL ONLY NAME OF DOCUMENT WHERE AGE IS 25

ğŸ”¹ Without condition:

db.collection.find({}, { name: 1, _id: 0 })         SHOWS ONLY NAME OF ALL DOCUMENTS 



2ï¸âƒ£ Why MongoDB is Schemaless
MongoDB collections donâ€™t require a fixed structure.
You can store documents with different fields and types.

EXAMPLE 
// Document 1
{ _id: 1, name: "Amit" }

// Document 2
{ _id: 2, name: "Rohit", city: "Mumbai" }

ğŸ’¡ This flexibility is what makes MongoDB schemaless.


3ï¸âƒ£ Data Types in MongoDB

String â†’ "name": "Amit"

Number â†’ "age": 25

Boolean â†’ "isActive": true

Array â†’ "skills": ["JS", "Python"]

Object â†’ "address": { city: "Pune" }



4ï¸âƒ£ Check Type of a Field in JS (Mongo Shell)

typeof "hello"       // string
typeof 25            // number
typeof true          // boolean
typeof [1,2]         // object (array is a type of object)
typeof {a:1}         // object


5ï¸âƒ£ Drop/Delete Collection

db.collection.drop()        // Deletes the whole collection.


6ï¸âƒ£ Drop/Delete Database

db.dropDatabase()        //Deletes the current database.



âœ… What is ordered in MongoDB?
When you use insertMany(), MongoDB by default uses:

EXAMPLE : { ordered: true }

That means:
1.It inserts documents one by one in order.
2.If one document fails, it stops and doesnâ€™t insert the rest.



ğŸ“Œ Summary:OF ORDERED OPTION

ordered: true	Stops at first error âŒ
ordered: false	Continues even after errors âœ…




ğŸ“Œ 1. What is writeConcern?
writeConcern is used to control how MongoDB confirms a write operation (insert, update, delete).

It decides:
1).How safe you want your write
2).How fast it should be

ğŸ”§ 2. Full example :
   {w:<value> j: <bollean> wtimeout:number}

ğŸ”§ 3. Full example :
db.collection.insertOne(
  { name: "ram", age: 20 },
  {
    writeConcern: {
      w: 1,
      j: true,
      wtimeout: 5000
    }
  }
)

***ABOUT ALL OPTION(W=WRITE J=JOURNAL WTIMEOUT=WRITETIMEOUT)***

*w (Write Acknowledgment)
â¡ï¸ Syntax Examples:
writeConcern: { w: 0 }
writeConcern: { w: 1 }
writeConcern: { w: "majority" }
writeConcern: { w: 2 }  // in replica sets


ğŸ“ Meaning:

w: 0: Donâ€™t wait for acknowledgment (fastest but no guarantee).

w: 1: Wait for primary server to confirm (default, safe).

w: "majority": Wait for most replica nodes to confirm (super safe).



ğŸ“Œ Use:

w: 0: For logs/temp data.

w: 1: For common safe writes.

w: "majority": For critical data.



**ğŸ’¾ j (Journal Write)
â¡ï¸ Syntax:
writeConcern: { j: true }
writeConcern: { j: false }

ğŸ“ Meaning:

j: true: Wait until write is stored in journal (disk-safe).

j: false: Donâ€™t wait for journaling (faster).



ğŸ“Œ Use:

j: true: Use when data must not be lost even if power fails.

j: false: Use for speed when durability isnâ€™t critical.



***â±ï¸ wtimeout (Wait Timeout)
â¡ï¸ Syntax:
writeConcern: { w: 1, wtimeout: 3000 }


ğŸ“ Meaning:

Wait max 3000ms (3 sec) for write acknowledgment.
If write not confirmed within timeout â†’ error.


ğŸ“Œ Use:

Prevents app from hanging too long on write delays.





âœ… Atomicity in MongoDB â€“ Simple Theory

ğŸ“Œ What is Atomicity?
Atomicity means:
"All or nothing" â€” the operation completes fully or doesnâ€™t happen at all.

ğŸ“ Where is Atomicity in MongoDB?
1. âœ… At Document Level
MongoDB operations (like insert, update, delete) are atomic on a single document.
Even if the document is big or nested (has arrays, embedded docs), changes inside it are atomic.


2. ğŸ” For Multiple Documents (Using Transactions)
If you want atomicity across multiple documents or collections, you need to use transactions.

Transactions ensure all operations succeed or none do (just like in SQL databases).


ğŸ”’ Why Atomicity is Important?
Keeps data consistent
Prevents half-updated or broken states



ğŸ§  Summary:
      Level                             Atomicity
Single Document	        âœ… Yes
Multiple Documents	âŒ (without transaction) / âœ… (with transaction)





âœ… we,can import JSON into MongoDB

ğŸ› ï¸ Tool used:
mongoimport â€“ a MongoDB CLI tool for importing data.

ğŸ“Œ Basic Syntax:
mongoimport --db yourDB --collection yourCollection --file yourFile.json --jsonArray

ğŸ§¾ Explanation of each part:
   Option	                  Meaning
--db yourDB	            Your database name
--collection                yourCollection	Your collection name
--file yourFile.json	    Path to your JSON file (can be full path)
--jsonArray	            If your JSON file has an array of docs



ğŸ“‚ Example:
You have a file students.json like:

[
  { "name": "ram", "age": 20 },
  { "name": "shyam", "age": 21 }
]


Use this command:
mongoimport --db school --collection students --file students.json --jsonArray




ğŸ”„ Important Notes:
Your MongoDB server must be running before using this.
mongoimport is used from terminal or VS Code terminal (not from inside the Mongo shell).
The file must be valid JSON.
