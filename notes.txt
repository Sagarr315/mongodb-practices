1. What is MongoDB?
MongoDB is a NoSQL database â€” unlike traditional databases (like MySQL or SQL Server) that use tables,
MongoDB stores data in a flexible, JSON-like format called documents.
Itâ€™s perfect for applications where data structure can change often (like modern web apps).


âœ¨ Main Features (Short & Sweet):
1.Document-Oriented: Data is stored in documents (like JSON objects).
2.Schema-less: You donâ€™t need to define the structure of data (no fixed columns).
3.High Performance: Super fast for read/write operations.
4.Scalable: Handles big data easily with horizontal scaling (adding more machines).
5.Flexible: You can store arrays, nested objects, etc.



ğŸ“„ Core Concepts
1. Database
Like a folder. Contains collections.

2. Collection
Like a table in SQL, but without fixed schema. Contains documents.

Example:
users collection, products collection

3. Document
Like a row in SQL, but in JSON format.

Example:{
  "name": "John",
  "age": 25,
  "email": "john@example.com"
}

Each document can have different fields. One document can have "age", another might not.



4. _id
Every document automatically gets a unique _id field (like a primary key).

Differences Between SQL VS MongoDB Terminology:

SQL	          MongoDB

Table	         Collection
Row	         Document
Column	         Field
Primary Key	 _id
JOIN	         Embedding/Nesting (or $lookup for joins)



CRUD Operations

           READ USING:  1.find()  and  findOne()

ğŸ” find() vs findOne()

       Command                              Description
	
	find()	        Returns all matching documents as a cursor (like a pointer).
	findOne()	Returns only the first matching document (just one object).

*Cursor (from find())

	1.Acts like a pointer to the result set.
	2.You can loop through it or use .toArray() or .pretty() to display data.



*What is a Cursor in MongoDB?

	A cursor is like a pointer or iterator that MongoDB returns when you run find().

	It doesn't give you all the data at once â€” instead, it gives you a stream of documents, so you can:
	Scroll through large results efficiently
	Use .forEach(), .toArray(), or .pretty() to handle the data

*Think of it like:
        A remote control that points to your data â€” you press "next" to fetch more as needed!                

*CREATE OPERATIONS with insert 
ğŸ“¥ insertOne()
Inserts a single document into a collection.

ğŸ“¥ insertMany()
Inserts multiple documents at once (array of documents).


***UPDATE OPERATIONS

âœï¸ updateOne()
Updates only the first matching document.

âœï¸ updateMany()
Updates all matching documents.


***DElETE OPERATIONS
âŒ deleteOne()
Deletes only the first matching document.

âŒ deleteMany()
Deletes all matching documents





1ï¸âƒ£Select one field (column) from documents
ğŸ”¹ With condition:

db.collection.find({ age: 25 }, { name: 1, _id: 0 })    IT WILL ONLY NAME OF DOCUMENT WHERE AGE IS 25

ğŸ”¹ Without condition:

db.collection.find({}, { name: 1, _id: 0 })         SHOWS ONLY NAME OF ALL DOCUMENTS 



2ï¸âƒ£ Why MongoDB is Schemaless
MongoDB collections donâ€™t require a fixed structure.
You can store documents with different fields and types.

EXAMPLE 
// Document 1
{ _id: 1, name: "Amit" }

// Document 2
{ _id: 2, name: "Rohit", city: "Mumbai" }

ğŸ’¡ This flexibility is what makes MongoDB schemaless.


3ï¸âƒ£ Data Types in MongoDB

String â†’ "name": "Amit"

Number â†’ "age": 25

Boolean â†’ "isActive": true

Array â†’ "skills": ["JS", "Python"]

Object â†’ "address": { city: "Pune" }



4ï¸âƒ£ Check Type of a Field in JS (Mongo Shell)

typeof "hello"       // string
typeof 25            // number
typeof true          // boolean
typeof [1,2]         // object (array is a type of object)
typeof {a:1}         // object


5ï¸âƒ£ Drop/Delete Collection

db.collection.drop()        // Deletes the whole collection.


6ï¸âƒ£ Drop/Delete Database

db.dropDatabase()        //Deletes the current database.



âœ… What is ordered in MongoDB?
When you use insertMany(), MongoDB by default uses:

EXAMPLE : { ordered: true }

That means:
1.It inserts documents one by one in order.
2.If one document fails, it stops and doesnâ€™t insert the rest.



ğŸ“Œ Summary:OF ORDERED OPTION

ordered: true	Stops at first error âŒ
ordered: false	Continues even after errors âœ…




ğŸ“Œ 1. What is writeConcern?
writeConcern is used to control how MongoDB confirms a write operation (insert, update, delete).

It decides:
1).How safe you want your write
2).How fast it should be

ğŸ”§ 2. Full example :
   {w:<value> j: <bollean> wtimeout:number}

ğŸ”§ 3. Full example :
db.collection.insertOne(
  { name: "ram", age: 20 },
  {
    writeConcern: {
      w: 1,
      j: true,
      wtimeout: 5000
    }
  }
)

**ABOUT ALL OPTION(W=WRITE J=JOURNAL WTIMEOUT=WRITETIMEOUT)**

w (Write Acknowledgment)
â¡ï¸ Syntax Examples:
writeConcern: { w: 0 }
writeConcern: { w: 1 }
writeConcern: { w: "majority" }
writeConcern: { w: 2 }  // in replica sets


ğŸ“ Meaning:

w: 0: Donâ€™t wait for acknowledgment (fastest but no guarantee).

w: 1: Wait for primary server to confirm (default, safe).

w: "majority": Wait for most replica nodes to confirm (super safe).



ğŸ“Œ Use:

w: 0: For logs/temp data.

w: 1: For common safe writes.

w: "majority": For critical data.



ğŸ’¾ j (Journal Write)
â¡ï¸ Syntax:
writeConcern: { j: true }
writeConcern: { j: false }

ğŸ“ Meaning:

j: true: Wait until write is stored in journal (disk-safe).

j: false: Donâ€™t wait for journaling (faster).



ğŸ“Œ Use:

j: true: Use when data must not be lost even if power fails.

j: false: Use for speed when durability isnâ€™t critical.