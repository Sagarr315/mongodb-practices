1. What is MongoDB?
MongoDB is a NoSQL database ‚Äî unlike traditional databases (like MySQL or SQL Server) that use tables,
MongoDB stores data in a flexible, JSON-like format called documents.
It‚Äôs perfect for applications where data structure can change often (like modern web apps).


‚ú® Main Features (Short & Sweet):
1.Document-Oriented: Data is stored in documents (like JSON objects).
2.Schema-less: You don‚Äôt need to define the structure of data (no fixed columns).
3.High Performance: Super fast for read/write operations.
4.Scalable: Handles big data easily with horizontal scaling (adding more machines).
5.Flexible: You can store arrays, nested objects, etc.



üìÑ Core Concepts
1. Database
Like a folder. Contains collections.

2. Collection
Like a table in SQL, but without fixed schema. Contains documents.

Example:
users collection, products collection

3. Document
Like a row in SQL, but in JSON format.

Example:{
  "name": "John",
  "age": 25,
  "email": "john@example.com"
}

Each document can have different fields. One document can have "age", another might not.



4. _id
Every document automatically gets a unique _id field (like a primary key).

Differences Between SQL VS MongoDB Terminology:

SQL	          MongoDB

Table	         Collection
Row	         Document
Column	         Field
Primary Key	 _id
JOIN	         Embedding/Nesting (or $lookup for joins)



CRUD Operations

           READ USING:  1.find()  and  findOne()

üîç find() vs findOne()

       Command                              Description
	
	find()	        Returns all matching documents as a cursor (like a pointer).
	findOne()	Returns only the first matching document (just one object).

*Cursor (from find())

	1.Acts like a pointer to the result set.
	2.You can loop through it or use .toArray() or .pretty() to display data.



*What is a Cursor in MongoDB?

	A cursor is like a pointer or iterator that MongoDB returns when you run find().

	It doesn't give you all the data at once ‚Äî instead, it gives you a stream of documents, so you can:
	Scroll through large results efficiently
	Use .forEach(), .toArray(), or .pretty() to handle the data

*Think of it like:
        A remote control that points to your data ‚Äî you press "next" to fetch more as needed!                

*CREATE OPERATIONS with insert 
üì• insertOne()
Inserts a single document into a collection.

üì• insertMany()
Inserts multiple documents at once (array of documents).


***UPDATE OPERATIONS

‚úèÔ∏è updateOne()
Updates only the first matching document.

‚úèÔ∏è updateMany()
Updates all matching documents.


***DElETE OPERATIONS
‚ùå deleteOne()
Deletes only the first matching document.

‚ùå deleteMany()
Deletes all matching documents





1Ô∏è‚É£Select one field (column) from documents
üîπ With condition:

db.collection.find({ age: 25 }, { name: 1, _id: 0 })    IT WILL ONLY NAME OF DOCUMENT WHERE AGE IS 25

üîπ Without condition:

db.collection.find({}, { name: 1, _id: 0 })         SHOWS ONLY NAME OF ALL DOCUMENTS 



2Ô∏è‚É£ Why MongoDB is Schemaless
MongoDB collections don‚Äôt require a fixed structure.
You can store documents with different fields and types.

EXAMPLE 
// Document 1
{ _id: 1, name: "Amit" }

// Document 2
{ _id: 2, name: "Rohit", city: "Mumbai" }

üí° This flexibility is what makes MongoDB schemaless.


3Ô∏è‚É£ Data Types in MongoDB

String ‚Üí "name": "Amit"

Number ‚Üí "age": 25

Boolean ‚Üí "isActive": true

Array ‚Üí "skills": ["JS", "Python"]

Object ‚Üí "address": { city: "Pune" }



4Ô∏è‚É£ Check Type of a Field in JS (Mongo Shell)

typeof "hello"       // string
typeof 25            // number
typeof true          // boolean
typeof [1,2]         // object (array is a type of object)
typeof {a:1}         // object


5Ô∏è‚É£ Drop/Delete Collection

db.collection.drop()        // Deletes the whole collection.


6Ô∏è‚É£ Drop/Delete Database

db.dropDatabase()        //Deletes the current database.



‚úÖ What is ordered in MongoDB?
When you use insertMany(), MongoDB by default uses:

EXAMPLE : { ordered: true }

That means:
1.It inserts documents one by one in order.
2.If one document fails, it stops and doesn‚Äôt insert the rest.



üìå Summary:OF ORDERED OPTION

ordered: true	Stops at first error ‚ùå
ordered: false	Continues even after errors ‚úÖ




üìå 1. What is writeConcern?
writeConcern is used to control how MongoDB confirms a write operation (insert, update, delete).

It decides:
1).How safe you want your write
2).How fast it should be

üîß 2. Full example :
   {w:<value> j: <bollean> wtimeout:number}

üîß 3. Full example :
db.collection.insertOne(
  { name: "ram", age: 20 },
  {
    writeConcern: {
      w: 1,
      j: true,
      wtimeout: 5000
    }
  }
)

***ABOUT ALL OPTION(W=WRITE J=JOURNAL WTIMEOUT=WRITETIMEOUT)***

*w (Write Acknowledgment)
‚û°Ô∏è Syntax Examples:
writeConcern: { w: 0 }
writeConcern: { w: 1 }
writeConcern: { w: "majority" }
writeConcern: { w: 2 }  // in replica sets


üìù Meaning:

w: 0: Don‚Äôt wait for acknowledgment (fastest but no guarantee).

w: 1: Wait for primary server to confirm (default, safe).

w: "majority": Wait for most replica nodes to confirm (super safe).



üìå Use:

w: 0: For logs/temp data.

w: 1: For common safe writes.

w: "majority": For critical data.



**üíæ j (Journal Write)
‚û°Ô∏è Syntax:
writeConcern: { j: true }
writeConcern: { j: false }

üìù Meaning:

j: true: Wait until write is stored in journal (disk-safe).

j: false: Don‚Äôt wait for journaling (faster).



üìå Use:

j: true: Use when data must not be lost even if power fails.

j: false: Use for speed when durability isn‚Äôt critical.



***‚è±Ô∏è wtimeout (Wait Timeout)
‚û°Ô∏è Syntax:
writeConcern: { w: 1, wtimeout: 3000 }


üìù Meaning:

Wait max 3000ms (3 sec) for write acknowledgment.
If write not confirmed within timeout ‚Üí error.


üìå Use:

Prevents app from hanging too long on write delays.





‚úÖ Atomicity in MongoDB ‚Äì Simple Theory

üìå What is Atomicity?
Atomicity means:
"All or nothing" ‚Äî the operation completes fully or doesn‚Äôt happen at all.

üìç Where is Atomicity in MongoDB?
1. ‚úÖ At Document Level
MongoDB operations (like insert, update, delete) are atomic on a single document.
Even if the document is big or nested (has arrays, embedded docs), changes inside it are atomic.


2. üîÅ For Multiple Documents (Using Transactions)
If you want atomicity across multiple documents or collections, you need to use transactions.

Transactions ensure all operations succeed or none do (just like in SQL databases).


üîí Why Atomicity is Important?
Keeps data consistent
Prevents half-updated or broken states



üß† Summary:
      Level                             Atomicity
Single Document	        ‚úÖ Yes
Multiple Documents	‚ùå (without transaction) / ‚úÖ (with transaction)





‚úÖ we,can import JSON into MongoDB

üõ†Ô∏è Tool used:
mongoimport ‚Äì a MongoDB CLI tool for importing data.

üìå Basic Syntax:
mongoimport --db yourDB --collection yourCollection --file yourFile.json --jsonArray

üßæ Explanation of each part:
   Option	                  Meaning
--db yourDB	            Your database name
--collection                yourCollection	Your collection name
--file yourFile.json	    Path to your JSON file (can be full path)
--jsonArray	            If your JSON file has an array of docs



üìÇ Example:
You have a file students.json like:

[
  { "name": "ram", "age": 20 },
  { "name": "shyam", "age": 21 }
]


Use this command:
mongoimport --db school --collection students --file students.json --jsonArray




üîÑ Important Notes:
Your MongoDB server must be running before using this.
mongoimport is used from terminal or VS Code terminal (not from inside the Mongo shell).
The file must be valid JSON.






üìä Comparison Operators (Used to compare values)

Operator		Definition

$eq		Checks if values are equal.
$ne		Checks if values are not equal.
$lt		Checks if value is less than given value.
$gt		Checks if value is greater than given value.
$lte		Checks if value is less than or equal to.
$gte		Checks if value is greater than or equal to.
$in		Checks if value exists in a given array.
$nin		Checks if value does NOT exist in a given array.




üß† Logical Operators (Used to combine multiple conditions)

Operator	    Definition

$and		Joins multiple conditions, all must be true.
$or		Joins conditions, at least one must be true.
$not		Negates the condition (returns opposite).
$nor		Returns true only if all conditions are false.




üîé $exists
üìå Definition:
Checks whether a field exists or not in a document.

üß† Use:
true ‚Üí Field must be present

false ‚Üí Field must be absent

üß¨ $type
üìå Definition:
Checks the data type of a field‚Äôs value.

üß† Use:
Used to match values of a specific BSON type like:

string, int, bool, array, object, etc.

You can also use type number codes (e.g., 2 for string, 16 for int).




üîç Special Operators in MongoDB

Operator		Definition / Use

$expr		Allows you to use aggregation expressions inside a query. Helps compare fields with each other (like "price" > "cost").
$regex		Used to match string patterns (like search using part of a word or case-insensitive matching).
$mod		Used to match numbers using modulus (e.g., find numbers divisible by 5).
$jsonSchema	Validates documents using schema rules (like required fields, data types, etc.).
$text		Used to perform text search on string content (like full-text search).()
		
‚úÖ What to Do Before Using $text
You must create a text index on the field(s) where you want to perform text search.
You can create a text index on:
A single field
Or multiple fields
Only fields with a text index can be used in a $text query.



üß∫ Array Operators in MongoDB

Operator	Use / Definition
$size	Matches documents where the array has a specific number of elements.
$elemMatch	Matches documents where at least one element in the array matches all the specified conditions.
$all	Matches documents where the array contains all the specified elements, in any order.
$in	Matches documents where the field‚Äôs value is in the given array of values (can be used on arrays and non-arrays too).



üìö Theory: Sorting in MongoDB
üîπ What is Sorting?
Sorting is used to arrange the output of a query in ascending or descending order based on one or more fields.

üîπ Syntax:
db.collection.find().sort({ fieldName: 1 })   // Ascending
db.collection.find().sort({ fieldName: -1 })  // Descending
 
1 ‚Üí Ascending (small to large / A to Z)

-1 ‚Üí Descending (large to small / Z to A)

üîπ Why it's effortless?
No need to write complex logic.
Just mention the field and direction (1 or -1).
Can sort by multiple fields too (priority left to right).


